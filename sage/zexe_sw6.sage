"""
https://cryptosith.org/michael/data/talks/2013-08-01-SIAMAG13.pdf
https://www.issac-conference.org/2015/Slides/Schost.pdf
http://www.craigcostello.com.au/pairings/PairingsForBeginners.pdf
"""

fresh_compute = False   # Perform expensive-(ish) computations for curve orders

field_modulus = 22369874298875696930346742206501054934775599465297184582183496627646774052458024540232479018147881220178054575403841904557897715222633333372134756426301062487682326574958588001132586331462553235407484089304633076250782629492557320825577
desired_curve_order = 258664426012969094010652733694893533536393512754914660539884262666720468348340822774968888139573360124440321458177

# Find smallest extension field divisible by desired curve order
for pairing_degree in range(1, 12):
    if pairing_degree % 2 != 0:
        continue # must be even
    x = (field_modulus**pairing_degree)-1
    if x % desired_curve_order == 0:
        break
assert pairing_degree == 6

Fp = GF(field_modulus)

PARAM_A4 = Fp(5)
PARAM_A6 = Fp(17764315118651679038286329069295091506801468118146712649886336045535808055361274148466772191243305528312843236347777260247138934336850548243151534538734724191505953341403463040067571652261229308333392040104884438208594329793895206056414)

E = EllipticCurve(Fp, [PARAM_A4, PARAM_A6])

if fresh_compute:
    E_order = E.order()
else:
    E_order = 22369874298875696930346742206501054934775599465297184582183496627646774052458024540232479018147881220178054575403841904051432769089239847299357653499964436542832386963976320141304045324744586708834290383178262634904444967718221365125956

assert E_order % desired_curve_order == 0
E_cofactor = E_order // desired_curve_order
print '# E_order', E_order
print '# E_cofactor', E_cofactor

print('# E A4', Fp.vector_space()(E.a4()))
print('# E A6', Fp.vector_space()(E.a6()))

R.<T> = PolynomialRing(Fp)

assert field_modulus % 3 == 1


def find_non_residue(field, exponents):
    """
    Find non-residue in the field
    Must not be residue from any of the exponents
    e.g. find_non_residue(Fp, [2,3])  # no quadratic or cubic residues
    """
    g = field.gen()
    r = list()
    for e in exponents:
        r.append( (field.cardinality()-1)//e )
    for i in range(1, 2**10):
        nr = g+i
        failed = False
        for _ in r:
            if nr**_ == field(1):
                failed = True
                break
            if failed:
                break
        if failed:
            continue
        return nr

fp_non_residue = find_non_residue(Fp, [2,3])

Fp3.<u> = Fp.extension(T^3 - fp_non_residue)

E2 = EllipticCurve(Fp3, [E.a4() * (u**2), E.a6() * (u**3)])
print(E2)
print('# E2 A4', Fp3.vector_space()(E2.a4()))
print('# E2 A6', Fp3.vector_space()(E2.a6()))

if fresh_compute:
    E2_order = E2.order()
else:
    E2_order = 11194137345159537096108363490665619704866408361886658520558772227555313898508781311480310772226510689585105013245120673604104943368639255517300575713126164806947808685009483218431740622419222524615138240107289658328953869135610519931061989251823436202428776926763209857175055039116448322514546224758127644563663577550154707189585545390411353506556885650518703154241467658595998386258451604959736618578717583150572183233012032658357216865697896629844045997602806371916878894244189416741975219267657845954408270635162612245360200105264870609282025361472378746736609608505206566150870020810323134409611511279830225394508461850919774074946376247606256564162303420623676628965149799748634121758870575109568269200

assert (E2_order % desired_curve_order) == 0
E2_cofactor = E2_order // desired_curve_order
print('# E2 order', E2_order)



def find_generator(E, F, cofactor, order):
    g = F.gen()
    for x in range(1, 10**3):
        x = g+x
        y2 = x**3 + (E.a4()*x) + E.a6()
        if not y2.is_square():
            print 'Failed', x
            continue
        y = y2.sqrt()
        p = cofactor*E(x, y)
        if not p.is_zero() and (order*p).is_zero():
            # Choose the 'positive' point, where the Y coordinate is the lowest
            # This is an arbitrary choice... but allows for consistency across implementations
            negy = -p[1]
            if negy < p[1]:
                return -p
            return p


G1 = find_generator(E, Fp, E_cofactor, E_order)
G2 = find_generator(E2, Fp3, E2_cofactor, E2_order)

# See: http://www.craigcostello.com.au/pairings/PairingsForBeginners.pdf page 62

# Fp6 is quadratic over cubic, but can be constructed directly given the non-residue is neither quadratic nor cubic
Fp6.<v> = Fp.extension(T^6 - fp_non_residue)


# Allow projection of elements from Fp3 to Fp6
# See: http://doc.sagemath.org/html/en/reference/finite_rings/sage/rings/finite_rings/hom_finite_field.html
from sage.rings.finite_rings.hom_finite_field import FiniteFieldHomomorphism_generic
hom36 = FiniteFieldHomomorphism_generic(Hom(Fp3, Fp6))
hom63 = hom36.section()
# assert hom63(hom36(G2[0])) == G2[0]


homp3 = FiniteFieldHomomorphism_generic(Hom(Fp, Fp3))
hom3p = homp3.section()

# E2 is a twist of ET
# ET = EllipticCurve(Fp6, [E.a4()^6, E.a6()^6])
ET = EllipticCurve(Fp6, [hom36(E2.a4()), hom36(E2.a6())])
GT = ET(hom36(G2[0]), hom36(G2[1]))
assert GT*desired_curve_order == ET(0)


def twist_E2_to_ET(p):
    return ET(hom36(p[0]), hom36(p[1]))


homp6 = FiniteFieldHomomorphism_generic(Hom(Fp, Fp6))
def map_E_to_ET(p):
    return (homp6(p[0]), homp6(p[1]))

"""
derp6 = hom63(ET.a6()/(v^6))
derp4 = hom63(ET.a4()/(v^4))
Ederp = EllipticCurve(Fp3, [derp4, derp6])
sage: Ederp_cofactor = Ederp.order() / desired_curve_order
sage: E2_cofactor
43276679045916726782882096851503554444292580777869919574700824986947162516693702667493938255647666346010819253090121562084993205202476199057555142869892665220155573207800985012241638987472334344174208389303164492698303448192856551557283997344470334833850065978668184377503856699635686872344035470027430053642178229054516302338812152178131995800255516474185251732445975837621097393375441662426280154371264547168198834382681059556891327702516519955053315674076980350109237328216856859758931256208439575383786363605925879337208599843910819433766160937121108797819223653884174994325142959644019600
sage: Ederp_cofactor
43276679045916726782882096851503554444292580777869919574700824986947162516693702667493938255647666346010819253090121562084993205202476199057555142869892665220155573207800985012241638987472334344174208389303164492698303448192856551557283997344470334833850065978668184377503856699635686872344035470027430053642178229054516302338812152178131995800255516474447048535308819520194831651001707245541706132122919809972809295446341284316618145199455147939779578786669710961760537472584780730790352300632528430959780861881279080828969459061005555123661834403583506303597958294164527772920019463117322084
sage: find_generator(Ederp, Fp3, Ederp_cofactor, Ederp.order())
(8394757527340708305940238908509871665952316385521502688615920440100770783330204175333102961042791793196813653743262013907151877031914679663338746202526069973349950570380036109586733296911314903927982009116826413002139595899680359698820 : 230957353204603277972822352607686374540951495361081445052337997626976019798663992869341038195521376460745264831485473598672970209057838483547351640910147319713440740136797308592918285478984982639632031540065741080555208351974111030583 : 1)
Ederp_G2 = find_generator(Ederp, Fp3, Ederp_cofactor, Ederp.order())


# From http://www.craigcostello.com.au/pairings/PairingsForBeginners.pdf
# Page 63, d = 2 quadratic twists
# then a quadratic twist is given by E'/F_{p^{k/2}} : y^2 = x^3 + aw^4x + bw^6,
# with w in F_{q^k}, but w^2 in F_{q^{k/2}}. Since w^3 in F_{q^k} the isomorphism
# E' -> E dfined by Psi : (x',y') -> (x'/w^2, y'/w^3) will take elements in E'(F_{q^{k/2}})
# to elements in E(F_{q^k})
merp4 = PARAM_A4*(u^4)
merp6 = PARAM_A6*(u^6)
Emerp = EllipticCurve(Fp3, [merp4, merp6])
sage: Emerp.order()
11194137345159537096108363490665619704866408361886658520558772227555313898508781311480310772226510689585105013245120673604104943368639255517300575713126164806947808685009483218431740622419222524615138240107289658328953869135610519931061989251823436202428776926763209857175055039116448322514546224758127644563663577550154707189585545390411353506556885650586420673986015543824676101133563050839105637661172208704744006374457616563102465206082515224999451024714154537483793368519638308154717616034222281396299835613029039246383926899101472231974073350535280235598263240214893544655505280892655484286497311181628266492820433128361090075873550773367355614312128526791052263513284929006480195825218346054244480868
sage: Emerp_cofactor
43276679045916726782882096851503554444292580777869919574700824986947162516693702667493938255647666346010819253090121562084993205202476199057555142869892665220155573207800985012241638987472334344174208389303164492698303448192856551557283997344470334833850065978668184377503856699635686872344035470027430053642178229054516302338812152178131995800255516474447048535308819520194831651001707245541706132122919809972809295446341284316618145199455147939779578786669710961760537472584780730790352300632528430959780861881279080828969459061005555123661834403583506303597958294164527772920019463117322084
sage: find_generator(Emerp, Fp3, Emerp_cofactor, Emerp.order())
Failed u + 1
Failed u + 2
Failed u + 3
(14806084202692701879266449424016058522167929139247412822253541950457850859814920340844086732679873029614568910274730132283004691164574974838802623204063429740232318314264758303753829733748780994523918508075784168631857291858084007750154*u^2 : 2013702914731780751695953198326511227119352095486374111195156399848037384771319739358423905189206366664549955574374008587227527894390423337559950127366928337174261979791704115786601191605169737961630410262103262328586710839943038502253 : 1)
Emerp_G2 = find_generator(Emerp, Fp3, Emerp_cofactor, Emerp.order())

merp4 = PARAM_A4*(u^4)
merp6 = PARAM_A6*(u^6)
Emerp_order = 11194137345159537096108363490665619704866408361886658520558772227555313898508781311480310772226510689585105013245120673604104943368639255517300575713126164806947808685009483218431740622419222524615138240107289658328953869135610519931061989251823436202428776926763209857175055039116448322514546224758127644563663577550154707189585545390411353506556885650586420673986015543824676101133563050839105637661172208704744006374457616563102465206082515224999451024714154537483793368519638308154717616034222281396299835613029039246383926899101472231974073350535280235598263240214893544655505280892655484286497311181628266492820433128361090075873550773367355614312128526791052263513284929006480195825218346054244480868
Emerp_cofactor = 43276679045916726782882096851503554444292580777869919574700824986947162516693702667493938255647666346010819253090121562084993205202476199057555142869892665220155573207800985012241638987472334344174208389303164492698303448192856551557283997344470334833850065978668184377503856699635686872344035470027430053642178229054516302338812152178131995800255516474447048535308819520194831651001707245541706132122919809972809295446341284316618145199455147939779578786669710961760537472584780730790352300632528430959780861881279080828969459061005555123661834403583506303597958294164527772920019463117322084
Emerp = EllipticCurve(Fp3, [merp4, merp6])
Emerp_G2 = find_generator(Emerp, Fp3, Emerp_cofactor, Emerp_order)
EmerpT = EllipticCurve(Fp6, [E.a4(), E.a6()])
Emerp_G2_T = EmerpT(Fp6( Emerp_G2[0]/u^2), Fp6(Emerp_G2[1]/u^3))
Emerp_G1_T = map_E_to_ET(G1)



# Ezerp2 cofactor matches hard-coded sw6 G2 cofactor constant from Zexe
zerp4 = PARAM_A4*(v^4)
zerp6 = PARAM_A6*(v^6)
Ezerp = EllipticCurve(Fp6, [zerp4, zerp6])
Ezerp2 = EllipticCurve(Fp3, [hom63(zerp4), hom63(zerp6)])
Ezerp_order = 11194137345159537096108363490665619704866408361886658520558772227555313898508781311480310772226510689585105013245120673604104943368639255517300575713126164806947808685009483218431740622419222524615138240107289658328953869135610519931061989251823436202428776926763209857175055039116448322514546224758127644563663577550154707189585545390411353506556885650518703154241467658595998386258451604959736618578717583150572183233012032658357216865697896629844045997602806371916878894244189416741975219267657845954408270635162612245360200105264870609282025361472378746736609608505206566150870020810323134409611511279830225394508461850919774074946376247606256564162303420623676628965149799748634121758870575109568269200
Ezerp_cofactor = Ezerp_order // desired_curve_order # 43276679045916726782882096851503554444292580777869919574700824986947162516693702667493938255647666346010819253090121562084993205202476199057555142869892665220155573207800985012241638987472334344174208389303164492698303448192856551557283997344470334833850065978668184377503856699635686872344035470027430053642178229054516302338812152178131995800255516474185251732445975837621097393375441662426280154371264547168198834382681059556891327702516519955053315674076980350109237328216856859758931256208439575383786363605925879337208599843910819433766160937121108797819223653884174994325142959644019600
Ezerp_G2 = find_generator(Ezerp2, Fp3, Ezerp_cofactor, Ezerp_order)
Ezerp_G2_T = EmerpT(hom36( Ezerp_G2[0]/v^2), hom36(Ezerp_G2[1]/u^3))
Ezerp_G1_T = map_E_to_ET(G1)
"""

"""
def line_function(A, B, P):
    # https://crypto.stanford.edu/pbc/notes/elliptic/tate.html
    if A==B:
        l = (3*A[0]^2)/(2*A[1])
    elif A == -B:
        return P[0]-A[0]
    else:
        l = (B[1]-A[1])/(B[0]-A[0])
    return l*(P[0]-A[0]) + A[1] - P[1]
"""

def line_function(P1, P2, T):
    """
    Create a function representing the line between P1 and P2, and evaluate it at T
    tangent if P1 == P2.
    vp3 = vertical line through P3 = P1 + P2
    """
    assert P1 and P2 and T  # No points-at-infinity allowed, sorry
    x1, y1 = P1[0], P1[1]
    x2, y2 = P2[0], P2[1]
    xt, yt = T[0], T[1]
    if x1 != x2:
        # Addition
        m = (y2 - y1) / (x2 - x1)
        return m * (xt - x1) - (yt - y1)
    elif y1 == y2:
        # Doubling
        m = 3 * x1**2 / (2 * y1)
        return m * (xt - x1) - (yt - y1)
    # P2 == -P1 or visa versa
    return xt - x1


def tate_miller_loop(P, Q, ds):
    R = Q
    f = Fp6.one()
    L = len(ds)
    for i in range(L-2, 0, -1):
        f = (f*f) * line_function(R, R, P)
        R = R*2
        if ds[i] == 1:
            f = f * line_function(R, Q, P)
            R = R + Q
    return f


def tate_miller_loop(P, Q, ate_loop_count):
    R = Q
    f = Fp6.one()
    log_ate_loop_count = floor(log(ate_loop_count, 2)) - 1
    for i in range(log_ate_loop_count, -1, -1):
        f = (f*f) * line_function(R, R, P)
        R = R*2
        if ate_loop_count & (2**i):         # addition step
            f = f * line_function(R, Q, P)
            R = R + Q
    return f


def pairing(P, Q):
    """Maps (G1 x G2) to a root of unity in Fp6"""
    ate_loop_count = 506464946133393486072777102926336625944849939610982267859828541006717966526573193706126370441346337661774335955699621
    ate_loop_bits = Integer(ate_loop_count).digits(2)
    assert ((ate_loop_count**6) - 1) % desired_curve_order == 0
    #final_exp = (Fp6.cardinality()-1)//desired_curve_order
    return tate_miller_loop(map_E_to_ET(P), twist_E2_to_ET(Q), ate_loop_bits)
